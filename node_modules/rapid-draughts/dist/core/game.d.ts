import { DraughtsPlayer } from './engine';
import type { Bitboard, DraughtsEngine, DraughtsEngineBoard, DraughtsEngineMove, DraughtsStatus } from './engine';
export type DraughtsPiece1D = {
    readonly king: boolean;
    readonly player: DraughtsPlayer;
};
export type DraughtsDarkSquare1D = {
    readonly piece: DraughtsPiece1D | undefined;
    readonly position: number;
    readonly dark: true;
};
export type DraughtsLightSquare1D = {
    readonly piece: undefined;
    readonly position: undefined;
    readonly dark: false;
};
export type DraughtsSquare1D = DraughtsLightSquare1D | DraughtsDarkSquare1D;
export type DraughtsBoard1D = DraughtsSquare1D[];
export type DraughtsMove1D = {
    readonly origin: number;
    readonly destination: number;
    readonly captures: number[];
};
export type DraughtsGameHistory1D = {
    moves: DraughtsMove1D[];
    boards: DraughtsBoard1D[];
};
export type DraughtsAdapter1D<T extends Bitboard> = {
    toMove1D: (engineMove: DraughtsEngineMove<T>) => DraughtsMove1D;
    toEngineMove: (move1D: DraughtsMove1D) => DraughtsEngineMove<T>;
    toBoard1D: (engineBoard: DraughtsEngineBoard<T>) => DraughtsBoard1D;
};
export declare class DraughtsGame1D<T extends Bitboard, E> {
    engine: DraughtsEngine<T, E>;
    history: DraughtsGameHistory1D;
    private _board;
    private _moves;
    private readonly adapter;
    constructor(engine: DraughtsEngine<T, E>, history: DraughtsGameHistory1D, adapter: DraughtsAdapter1D<T>);
    /**
     * Get the status of the game
     */
    get status(): DraughtsStatus;
    /**
     * Get the current player to move
     */
    get player(): DraughtsPlayer;
    /**
     * Get the 1D array representation of the current board
     */
    get board(): DraughtsBoard1D;
    /**
     * Get the available moves in 1D representation
     */
    get moves(): DraughtsMove1D[];
    /**
     * Check if a move is valid
     * @param move The move to check in 1D representation
     * @returns True if the move is valid, false otherwise.
     */
    isValidMove(move: DraughtsMove1D): boolean;
    /**
     * Make a move using the 1D representation of a move
     * @param move The move to make in 1D representation
     */
    move(move: DraughtsMove1D): void;
    asciiBoard(): string;
}
