import Long from 'long';
export declare enum DraughtsStatus {
    PLAYING = "playing",
    DRAW = "draw",
    LIGHT_WON = "light_won",
    DARK_WON = "dark_won"
}
export type Bitboard = number | Long;
export type DraughtsEngineBoard<T extends Bitboard> = {
    readonly light: T;
    readonly dark: T;
    readonly king: T;
};
export type DraughtsEngineMove<T extends Bitboard> = {
    readonly origin: T;
    readonly destination: T;
    readonly captures: T;
};
export declare enum DraughtsPlayer {
    LIGHT = "light",
    DARK = "dark"
}
export type DraughtsEngineData<T extends Bitboard, E> = {
    player: DraughtsPlayer;
    board: DraughtsEngineBoard<T>;
    store: E;
};
export type DraughtsEngineStrategy<T extends Bitboard, E> = {
    moves: (engine: DraughtsEngine<T, E>) => DraughtsEngineMove<T>[];
    status: (engine: DraughtsEngine<T, E>) => DraughtsStatus;
    isValidMove: (engine: DraughtsEngine<T, E>, move: DraughtsEngineMove<T>) => boolean;
    move: (engine: DraughtsEngine<T, E>, move: DraughtsEngineMove<T>) => DraughtsEngineData<T, E>;
    serializeStore: (store: E) => E;
};
export declare class DraughtsEngine<T extends Bitboard, E> {
    data: DraughtsEngineData<T, E>;
    private strategy;
    private _moves;
    private _status;
    constructor(data: DraughtsEngineData<T, E>, strategy: DraughtsEngineStrategy<T, E>);
    /**
     * Returns the current game status
     */
    get status(): DraughtsStatus;
    /**
     * Returns the available moves
     */
    get moves(): DraughtsEngineMove<T>[];
    /**
     * Clones the current engine instance
     * @returns A new cloned engine instance
     */
    clone(): DraughtsEngine<T, E>;
    /**
     * Serializes the engine data
     * @returns The serialized engine data
     */
    serialize(): DraughtsEngineData<T, E>;
    move(move: DraughtsEngineMove<T>): void;
    isValidMove(move: DraughtsEngineMove<T>): boolean;
}
