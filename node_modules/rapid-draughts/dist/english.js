var J = Object.defineProperty;
var U = (o, t, s) => t in o ? J(o, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : o[t] = s;
var f = (o, t, s) => (U(o, typeof t != "symbol" ? t + "" : t, s), s);
import { a as p, b as V, D as l } from "./engine-eb68f1f2.js";
function $(o, t) {
  return o.origin === t.origin && o.destination === t.destination && o.captures === t.captures;
}
function Y(o) {
  const t = Math.floor(Math.sqrt(o.length)), s = "-".repeat(1 + t * 4);
  let r = `${s}
`;
  for (const [e, i] of o.entries()) {
    if (e % t === 0 && (r += "|"), i.piece) {
      let c = i.piece.player === p.LIGHT ? "x" : "o";
      c = i.piece.king ? c.toUpperCase() : c, r += ` ${c} |`;
    } else
      r += "   |";
    e % t === t - 1 && (r += ` 
${s}
`);
  }
  return r;
}
class q {
  constructor(t, s, r) {
    f(this, "engine");
    f(this, "history");
    f(this, "_board");
    f(this, "_moves");
    f(this, "adapter");
    this.engine = t, this.history = s, this.adapter = r;
  }
  /**
   * Get the status of the game
   */
  get status() {
    return this.engine.status;
  }
  /**
   * Get the current player to move
   */
  get player() {
    return this.engine.data.player;
  }
  /**
   * Get the 1D array representation of the current board
   */
  get board() {
    return this._board ?? (this._board = this.adapter.toBoard1D(this.engine.data.board));
  }
  /**
   * Get the available moves in 1D representation
   */
  get moves() {
    return this._moves ?? (this._moves = this.engine.moves.map(
      (t) => this.adapter.toMove1D(t)
    ));
  }
  /**
   * Check if a move is valid
   * @param move The move to check in 1D representation
   * @returns True if the move is valid, false otherwise.
   */
  isValidMove(t) {
    const s = this.adapter.toEngineMove(t);
    return this.engine.isValidMove(s);
  }
  /**
   * Make a move using the 1D representation of a move
   * @param move The move to make in 1D representation
   */
  move(t) {
    if (!this.isValidMove(t))
      throw new Error(`invalid move: ${JSON.stringify(t)}`);
    this.history.boards.push(this.board), this.history.moves.push(t);
    const s = this.adapter.toEngineMove(t);
    this.engine.move(s), this._board = void 0, this._moves = void 0;
  }
  asciiBoard() {
    return Y(this.board);
  }
}
const I = 32, n = [];
n[0] = 1;
for (let o = 1; o < I; o++)
  n[o] = n[o - 1] * 2;
const N = 4294967295;
function u(o, t) {
  const s = t % I;
  return (o >>> s | o << I - s & N) >>> 0;
}
function h(o, t) {
  const s = t % I;
  return (o << s & N | o >>> I - s) >>> 0;
}
function E(o) {
  const t = [];
  for (let s = 1; o; s <<= 1)
    o & s && (t.push(s >>> 0), o ^= s);
  return t;
}
function R(o) {
  return o = o - (o >>> 1 & 1431655765), o = (o & 858993459) + (o >>> 2 & 858993459), o = (o + (o >>> 4) & 252645135) * 16843009 >>> 24, o;
}
const j = n[11] | n[5] | n[31] | n[25] | n[10] | n[4] | n[30] | n[24] | n[3] | n[29] | n[23] | n[17] | n[2] | n[28] | n[22] | n[16] | n[27] | n[21] | n[15] | n[9] | n[26] | n[20] | n[14] | n[8] | n[9] | n[3] | n[7] | n[1] | n[18] | n[12] | n[6] | n[0], D = n[18] | n[12] | n[6] | n[0], L = n[19] | n[13] | n[7] | n[1], K = n[26] | n[20] | n[14] | n[8], k = n[3] | n[29] | n[23] | n[17], O = n[10] | n[4] | n[30] | n[24], g = n[11] | n[5] | n[31] | n[25], w = n[18] | n[26] | n[2] | n[10], y = n[1] | n[9] | n[17] | n[25], z = ~(g | w), Q = ~(g | y), X = ~(D | w), Z = ~(D | y), tt = D | L | K, ot = k | O | g, st = n[21] | n[28] | n[22], nt = n[29] | n[22] | n[21] | n[14], a = {
  BOARD: j,
  RANK_0: D,
  RANK_1: L,
  RANK_2: K,
  RANK_5: k,
  RANK_6: O,
  RANK_7: g,
  FILE_0: w,
  FILE_7: y,
  FORWARD_LEFT: z,
  FORWARD_RIGHT: Q,
  BACKWARD_LEFT: X,
  BACKWARD_RIGHT: Z,
  LIGHT_START: tt,
  DARK_START: ot,
  MIDDLE_FOUR_RANK_TWO_FILE: nt,
  MIDDLE_TWO_RANK_FOUR_FILE: st
};
class T {
  constructor(t) {
    f(this, "forward");
    f(this, "backward");
    f(this, "opponent");
    f(this, "empty");
    this.forward = t.forward, this.backward = t.backward, this.opponent = t.opponent, this.empty = t.empty;
  }
  static fromPlayerAndBoard(t, s) {
    const r = t === p.LIGHT ? s.light : s.dark & s.king, e = t === p.LIGHT ? s.light & s.king : s.dark, i = t === p.LIGHT ? s.dark : s.light, c = ~(s.light | s.dark);
    return new T({
      forward: r,
      backward: e,
      opponent: i,
      empty: c
    });
  }
  getJumpers() {
    let t = u(this.empty, 7) & (this.opponent & a.FORWARD_LEFT), s = u(t, 7) & (this.forward & a.FORWARD_LEFT);
    return t = u(this.empty, 1) & (this.opponent & a.FORWARD_RIGHT), s |= u(t, 1) & (this.forward & a.FORWARD_RIGHT), t = h(this.empty, 1) & (this.opponent & a.BACKWARD_LEFT), s |= h(t, 1) & (this.backward & a.BACKWARD_LEFT), t = h(this.empty, 7) & (this.opponent & a.BACKWARD_RIGHT), s |= h(t, 7) & (this.backward & a.BACKWARD_RIGHT), s;
  }
  getMovers() {
    let t = 0;
    return this.forward && (t |= u(this.empty, 7) & this.forward & a.FORWARD_LEFT, t |= u(this.empty, 1) & this.forward & a.FORWARD_RIGHT), this.backward && (t |= h(this.empty, 1) & this.backward & a.BACKWARD_LEFT, t |= h(this.empty, 7) & this.backward & a.BACKWARD_RIGHT), t;
  }
  getMovesFromOrigin(t) {
    const s = [];
    if (t & this.forward) {
      const r = (h(t & a.FORWARD_LEFT, 7) & this.empty) >>> 0;
      r && s.push({ origin: t, destination: r, captures: 0 });
      const e = (h(t & a.FORWARD_RIGHT, 1) & this.empty) >>> 0;
      e && s.push({ origin: t, destination: e, captures: 0 });
    }
    if (t & this.backward) {
      const r = u(t & a.BACKWARD_LEFT, 1) & this.empty;
      r && s.push({ origin: t, destination: r, captures: 0 });
      const e = u(t & a.BACKWARD_RIGHT, 7) & this.empty;
      e && s.push({ origin: t, destination: e, captures: 0 });
    }
    return s;
  }
  getJumpsFromOrigin(t) {
    const s = this.getSingleJumpFromOrigin(t), r = [];
    for (; s.length > 0; ) {
      const e = s.pop();
      if (e === void 0)
        break;
      const c = this._fromMove({
        ...e,
        origin: t
      }).getSingleJumpFromOrigin(
        e.destination
      );
      for (const d of c)
        s.push({
          origin: t,
          destination: d.destination,
          captures: e.captures | d.captures
        });
      c.length === 0 && r.push(e);
    }
    return r;
  }
  getSingleJumpFromOrigin(t) {
    const s = [];
    if (t & this.forward) {
      const r = h(t & a.FORWARD_LEFT, 7) & this.opponent, e = (h(r & a.FORWARD_LEFT, 7) & this.empty) >>> 0;
      e && s.push({ origin: t, destination: e, captures: r });
      const i = h(t & a.FORWARD_RIGHT, 1) & this.opponent, c = (h(i & a.FORWARD_RIGHT, 1) & this.empty) >>> 0;
      c && s.push({ origin: t, destination: c, captures: i });
    }
    if (t & this.backward) {
      const r = u(t & a.BACKWARD_LEFT, 1) & this.opponent, e = u(r & a.BACKWARD_LEFT, 1) & this.empty;
      e && s.push({ origin: t, destination: e, captures: r });
      const i = u(t & a.BACKWARD_RIGHT, 7) & this.opponent, c = u(i & a.BACKWARD_RIGHT, 7) & this.empty;
      c && s.push({ origin: t, destination: c, captures: i });
    }
    return s;
  }
  _fromMove(t) {
    return new T({
      forward: this.forward & t.origin ? this.forward | t.destination : this.forward,
      backward: this.backward & t.origin ? this.backward | t.destination : this.backward,
      opponent: this.opponent & ~t.captures,
      empty: this.empty
    });
  }
}
const rt = {
  player: p.DARK,
  board: {
    light: a.LIGHT_START,
    dark: a.DARK_START,
    king: 0
  },
  store: {
    sinceCapture: 0,
    sinceNonKingAdvance: 0
  }
}, et = {
  serializeStore(o) {
    return {
      ...o
    };
  },
  status(o) {
    return o.moves.length === 0 ? o.data.player === p.LIGHT ? l.DARK_WON : l.LIGHT_WON : o.data.store.sinceCapture >= 40 && o.data.store.sinceNonKingAdvance >= 40 ? l.DRAW : l.PLAYING;
  },
  isValidMove(o, t) {
    return o.moves.some((s) => $(t, s));
  },
  moves(o) {
    const t = T.fromPlayerAndBoard(
      o.data.player,
      o.data.board
    ), s = [], r = t.getJumpers();
    if (r) {
      for (const i of E(r))
        s.push(...t.getJumpsFromOrigin(i));
      return s;
    }
    const e = t.getMovers();
    for (const i of E(e))
      s.push(...t.getMovesFromOrigin(i));
    return s;
  },
  move(o, t) {
    if (!o.isValidMove(t))
      throw new Error(`invalid move: ${JSON.stringify(t)}`);
    const s = {
      ...o.data.board
    }, r = { ...o.data.store };
    return s.light &= ~(t.origin | t.captures), s.dark &= ~(t.origin | t.captures), s.king &= ~(t.origin | t.captures), o.data.board.light & t.origin ? (s.light |= t.destination, s.king |= t.destination & a.RANK_7) : (s.dark |= t.destination, s.king |= t.destination & a.RANK_0), o.data.board.king & t.origin ? (s.king |= t.destination, r.sinceNonKingAdvance += 1) : r.sinceNonKingAdvance = 0, t.captures ? r.sinceCapture = 0 : r.sinceCapture += 1, {
      player: o.data.player === p.LIGHT ? p.DARK : p.LIGHT,
      board: s,
      store: r
    };
  }
}, it = {
  /**
   * Set up an English Draughts engine with optional data
   * @param data Optional data for the engine
   * @returns An English Draughts engine instance
   */
  setup(o) {
    return new V(
      { ...rt, ...o },
      et
    );
  }
}, A = [
  n[11],
  n[5],
  n[31],
  n[25],
  n[10],
  n[4],
  n[30],
  n[24],
  n[3],
  n[29],
  n[23],
  n[17],
  n[2],
  n[28],
  n[22],
  n[16],
  n[27],
  n[21],
  n[15],
  n[9],
  n[26],
  n[20],
  n[14],
  n[8],
  n[19],
  n[13],
  n[7],
  n[1],
  n[18],
  n[12],
  n[6],
  n[0]
], m = new Map(
  A.map((o, t) => [o, t])
), F = {
  toMove1D(o) {
    const t = m.get(o.origin);
    if (t === void 0)
      throw new Error(`invalid move origin: ${o.origin}`);
    const s = m.get(o.destination);
    if (s === void 0)
      throw new Error(`invalid move destination: ${o.destination}`);
    const r = [];
    for (const e of E(o.captures)) {
      const i = m.get(e);
      i !== void 0 && r.push(i);
    }
    return { origin: t, destination: s, captures: r };
  },
  toEngineMove(o) {
    const t = A[o.origin];
    if (t === void 0)
      throw new Error(`invalid move origin: ${o.origin}`);
    const s = A[o.destination];
    if (s === void 0)
      throw new Error(`invalid move destination: ${o.destination}`);
    let r = 0;
    for (const e of o.captures) {
      const i = A[e];
      if (i === void 0)
        throw new Error(`invalid move capture: ${e}`);
      r |= i;
    }
    return { origin: t, destination: s, captures: r };
  },
  toBoard1D(o) {
    const t = [];
    for (const [s, r] of A.entries()) {
      Math.floor(s / 4) % 2 === 0 && t.push({ dark: !1, piece: void 0, position: void 0 });
      const e = !!(r & o.light), i = !!(r & o.dark), c = !!(r & o.king);
      t.push({
        dark: !0,
        position: s,
        piece: e || i ? {
          player: e ? p.LIGHT : p.DARK,
          king: c
        } : void 0
      }), Math.floor(s / 4) % 2 !== 0 && t.push({ dark: !1, piece: void 0, position: void 0 });
    }
    return t;
  }
}, at = {
  moves: [],
  boards: []
}, Dt = {
  /**
   * Sets up a new English Draughts game
   * @param data Optional data to initialize the game engine
   * @param history Optional history to initialize the game
   * @returns The new English Draughts game
   */
  setup(o, t) {
    const s = it.setup(o);
    return new q(
      s,
      { ...at, ...t },
      F
    );
  }
}, v = {
  setup({
    adapter: o,
    strategy: t,
    options: s
  }) {
    return async (r) => {
      const e = await t({
        options: s,
        engine: r.engine
      });
      return o.toMove1D(e);
    };
  }
};
async function ct({
  options: { maxDepth: o, evaluationFunction: t, quiescence: s = !0 },
  engine: r
}) {
  let e = Number.NEGATIVE_INFINITY, i;
  for (const c of r.moves) {
    const d = r.clone();
    d.move(c);
    const _ = -await W({
      data: {
        engine: d,
        alpha: Number.NEGATIVE_INFINITY,
        beta: Number.POSITIVE_INFINITY,
        depth: o - 1
      },
      options: { evaluationFunction: t, quiescence: s }
    });
    _ >= e && (e = _, i = c);
  }
  if (i === void 0)
    throw new Error("no available moves");
  return i;
}
async function W({
  data: { engine: o, alpha: t, beta: s, depth: r },
  options: { evaluationFunction: e, quiescence: i }
}) {
  if (r === 0)
    return i ? G({
      data: { engine: o, alpha: t, beta: s },
      options: { evaluationFunction: e }
    }) : e(o);
  for (const c of o.moves) {
    const d = o.clone();
    d.move(c);
    const _ = -await W({
      data: {
        engine: d,
        alpha: -s,
        beta: -t,
        depth: r - 1
      },
      options: { evaluationFunction: e, quiescence: i }
    });
    if (_ >= s)
      return s;
    t = Math.max(_, t);
  }
  return t;
}
async function G({
  data: { engine: o, alpha: t, beta: s },
  options: { evaluationFunction: r }
}) {
  const e = r(o);
  if (e >= s)
    return s;
  t = Math.max(e, t);
  for (const i of o.moves) {
    if (!i.captures)
      continue;
    const c = o.clone();
    c.move(i);
    const d = -await G({
      data: { engine: c, alpha: -s, beta: -t },
      options: { evaluationFunction: r }
    });
    if (d >= s)
      return s;
    t = Math.max(d, t);
  }
  return t;
}
async function pt({
  engine: o
}) {
  if (o.moves.length === 0)
    throw new Error("no valid moves");
  const t = Math.floor(Math.random() * o.moves.length);
  return o.moves[t];
}
const dt = {
  [l.LIGHT_WON]: p.LIGHT,
  [l.DARK_WON]: p.DARK
}, ut = (o) => {
  const t = o.status;
  return t !== l.PLAYING ? t === l.DRAW ? Number.NEGATIVE_INFINITY : o.data.player === dt[t] ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : At(o);
}, ht = 50, ft = 77, Rt = 40, lt = 25, _t = 5;
function At(o) {
  const t = o.data.player === p.LIGHT ? o.data.board.light : o.data.board.dark, s = o.data.player === p.LIGHT ? o.data.board.dark : o.data.board.light, r = t & o.data.board.king, e = s & o.data.board.king, i = o.data.player === p.LIGHT ? a.RANK_0 : a.RANK_7, c = o.data.player === p.LIGHT ? a.RANK_7 : a.RANK_0, d = R(t), _ = R(s), M = R(r), H = R(e), b = R(t & i), C = R(s & c), B = R(
    t & a.MIDDLE_TWO_RANK_FOUR_FILE
  ), S = R(
    s & a.MIDDLE_TWO_RANK_FOUR_FILE
  ), x = R(
    t & a.MIDDLE_FOUR_RANK_TWO_FILE
  ), P = R(
    s & a.MIDDLE_FOUR_RANK_TWO_FILE
  );
  return (d - _) * ht + (M - H) * ft + (b - C) * Rt + (B - S) * lt + (x - P) * _t;
}
const gt = {
  /**
   * Creates a computer opponent with a random strategy
   * @returns {EnglishDraughtsComputer} - A computer opponent with a random strategy
   */
  random() {
    return v.setup({
      adapter: F,
      strategy: pt,
      options: void 0
    });
  },
  /**
   * Creates a computer opponent with an alpha-beta pruning strategy
   * @param {Partial<AlphaBetaOptions<number, EnglishDraughtsEngineStore>>} options - Options for the alpha-beta pruning strategy
   * @returns {EnglishDraughtsComputer} - A computer opponent with an alpha-beta pruning strategy
   */
  alphaBeta(o) {
    const t = {
      maxDepth: o.maxDepth ?? 4,
      quiescence: o.quiescence ?? !0,
      evaluationFunction: o.evaluationFunction ?? ut
    };
    return v.setup({
      adapter: F,
      strategy: ct,
      options: t
    });
  }
};
export {
  Dt as EnglishDraughts,
  n as EnglishDraughtsBitSquare,
  gt as EnglishDraughtsComputerFactory,
  it as EnglishDraughtsEngineFactory
};
//# sourceMappingURL=english.js.map
